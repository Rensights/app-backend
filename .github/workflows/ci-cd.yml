name: CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
      - develop
  push:
    branches:
      - main
      - develop
  workflow_dispatch: # For manual prod deployment

env:
  REGISTRY: ghcr.io
  DEV_NAMESPACE: dev
  PROD_NAMESPACE: prod

jobs:
  # Step 1: Test
  test:
    name: 1ï¸âƒ£ Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # Shallow clone for faster checkout

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Download Avro Schemas (cached)
        id: avro-schemas
        uses: actions/cache@v4
        with:
          path: schemas/avro
          key: avro-schemas-${{ hashFiles('**/.github/workflows/ci-cd.yml') }}
          restore-keys: |
            avro-schemas-
        continue-on-error: true

      - name: Download Avro Schemas
        if: steps.avro-schemas.outputs.cache-hit != 'true'
        run: |
          echo "ðŸ“¥ Downloading Avro schemas from avro-schemas image..."
          mkdir -p schemas/avro
          
          docker pull ghcr.io/rensights/avro-schemas:latest || {
            echo "âš ï¸  Warning: Could not pull avro-schemas:latest"
            echo "SKIP_AVRO=true" >> $GITHUB_ENV
            exit 0
          }
          
          docker create --name temp-schemas ghcr.io/rensights/avro-schemas:latest
          docker cp temp-schemas:/schemas/schemas/. schemas/avro/ || {
            echo "âš ï¸  Warning: Could not extract schemas from image"
            echo "SKIP_AVRO=true" >> $GITHUB_ENV
            docker rm temp-schemas
            exit 0
          }
          docker rm temp-schemas
          
          if [ -n "$(ls -A schemas/avro/*.avsc 2>/dev/null)" ]; then
            echo "âœ… Avro schemas downloaded successfully"
            echo "SKIP_AVRO=false" >> $GITHUB_ENV
          else
            echo "âš ï¸  No .avsc files found - skipping Avro generation"
            echo "SKIP_AVRO=true" >> $GITHUB_ENV
          fi

      - name: Build backend
        working-directory: src
        run: |
          SKIP_AVRO_VALUE="${SKIP_AVRO:-false}"
          echo "Building with skip.avro=${SKIP_AVRO_VALUE}"
          mvn clean package -DskipTests -Dskip.avro=${SKIP_AVRO_VALUE}

      - name: Run tests
        working-directory: src
        run: mvn test

  # Step 2: Build Docker Image
  build:
    name: 2ï¸âƒ£ Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.test.result == 'success'
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.image-tag.outputs.tag }}
    steps:
      - name: Set image tag (pipeline number)
        id: image-tag
        run: |
          RUN_NUMBER="${{ github.run_number }}"
          echo "tag=${RUN_NUMBER}" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}
          tags: |
            type=raw,value=${{ steps.image-tag.outputs.tag }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          cache-from: |
            type=gha
            type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            AVRO_SCHEMAS_VERSION=latest

      - name: Output image info
        run: |
          echo "âœ… Image pushed:"
          echo "${{ steps.meta.outputs.tags }}" | sed 's/^/   /'

  # Step 3: Deploy to Dev
  deploy-dev:
    name: 3ï¸âƒ£ Deploy to Dev
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && needs.build.result == 'success'
    timeout-minutes: 15
    environment: dev
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          spawn ssh-add "$env(HOME)/.ssh/id_ed25519"
          expect {
            "Enter passphrase" { send "$env(SSH_PASSPHRASE)\r"; exp_continue }
            "Identity added" { expect eof }
            timeout { exit 1 }
          }
          EXPECT_SCRIPT
          chmod +x /tmp/ssh-add.exp
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          /tmp/ssh-add.exp
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'" || exit 1

      - name: Setup SSH Tunnel to Kubernetes API
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:127.0.0.1:6443 root@72.62.40.154
          sleep 2

      - name: Configure kubectl
        run: |
          echo "${{ secrets.DEV_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          sed -i 's|server: https://.*:6443|server: https://127.0.0.1:6443|g' /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Ensure reports PVC exists (dev)
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl apply -f - <<'EOF'
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: reports-storage
            namespace: dev
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 5Gi
            storageClassName: local-path
          EOF

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Verify image exists
        run: |
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          IMAGE="${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${IMAGE_TAG}"
          echo "ðŸ” Verifying image exists: ${IMAGE}"
          docker manifest inspect ${IMAGE} >/dev/null 2>&1 || {
            echo "âš ï¸  Image ${IMAGE} not immediately available, checking latest..."
            docker manifest inspect ${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest >/dev/null 2>&1 || {
              echo "âŒ Image not found!"
              exit 1
            }
          }
          echo "âœ… Image verified"

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup microsoft-graph-credentials secret for dev
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret generic microsoft-graph-credentials \
            --from-literal=tenant-id='e84f3a33-9e68-4a68-aae3-bebba66459e6' \
            --from-literal=client-id='70a6e6ef-c980-47dc-89ea-70ebd47fd56d' \
            --from-literal=client-secret='${{ secrets.MICROSOFT_CLIENT_SECRET }}' \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy backend to dev
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          
          # Check for stuck Helm releases
          if helm list -n ${DEV_NAMESPACE} -q | grep -q "^backend$"; then
            STATUS=$(helm status backend -n ${DEV_NAMESPACE} -o json 2>/dev/null | jq -r '.info.status' 2>/dev/null || echo "unknown")
            if [[ "$STATUS" =~ ^(pending-install|pending-upgrade|pending-rollback|failed)$ ]]; then
              echo "âš ï¸  Cleaning up stuck release (status: $STATUS)..."
              helm rollback backend -n ${DEV_NAMESPACE} --force-replace 2>&1 || true
              sleep 3
              helm delete backend -n ${DEV_NAMESPACE} 2>&1 || true
              sleep 3
            fi
          fi
          
          echo "ðŸš€ Deploying to DEV with tag: ${IMAGE_TAG}"
          
          # Force update by adding a timestamp annotation that changes each time
          TIMESTAMP=$(date +%s)
          EXPECTED_REPO="${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}"
          
          helm upgrade --install backend ./charts \
            --namespace ${DEV_NAMESPACE} \
            --create-namespace \
            -f env-values/dev/global.yaml \
            -f env-values/dev/backend.yaml \
            --set reports.storage.path=/data/reports \
            --set reports.storage.existingClaim=reports-storage \
            --set image.tag=${IMAGE_TAG} \
            --set image.pullPolicy=Always \
            --set image.repository=${EXPECTED_REPO} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --set podAnnotations."deployment\.timestamp"=${TIMESTAMP} \
            --force-replace \
            --rollback-on-failure --timeout=8m || {
            
            echo "âš ï¸  Deployment failed or timed out, checking status..."
            kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=backend -o wide
            POD_PHASE=$(kubectl get pod -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=backend -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "")
            if [ "$POD_PHASE" = "Running" ]; then
              echo "âœ… Pod is running, deployment succeeded"
              exit 0
            fi
            exit 1
          }
          
          # Verify Helm set the values correctly
          echo "ðŸ” Verifying Helm release values..."
          HELM_IMAGE_TAG=$(helm get values backend -n ${DEV_NAMESPACE} -o json 2>/dev/null | jq -r '.image.tag // empty' 2>/dev/null || echo "")
          if [ "${HELM_IMAGE_TAG}" != "${IMAGE_TAG}" ]; then
            echo "âš ï¸  Warning: Helm values show tag '${HELM_IMAGE_TAG}' but expected '${IMAGE_TAG}'"
            echo "ðŸ”§ Re-running Helm upgrade with explicit tag..."
            helm upgrade backend ./charts \
              --namespace ${DEV_NAMESPACE} \
              -f env-values/dev/global.yaml \
              -f env-values/dev/backend.yaml \
              --set image.tag=${IMAGE_TAG} \
              --set image.pullPolicy=Always \
              --set image.repository=${EXPECTED_REPO} \
              --force-replace
          fi

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          echo "âœ… Dev Deployment Status:"
          kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=backend
          kubectl get svc -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=backend
          
          echo ""
          echo "ðŸ” Verifying deployed image tag..."
          DEPLOYED_IMAGE=$(kubectl get deployment backend -n ${DEV_NAMESPACE} -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "")
          echo "Deployed image: ${DEPLOYED_IMAGE}"
          echo "Expected tag: ${IMAGE_TAG}"
          
          EXPECTED_IMAGE="${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${IMAGE_TAG}"
          
          if echo "${DEPLOYED_IMAGE}" | grep -q ":${IMAGE_TAG}$"; then
            echo "âœ… Image tag matches!"
          else
            echo "âš ï¸  Warning: Image tag mismatch!"
            echo "   Current: ${DEPLOYED_IMAGE}"
            echo "   Expected: ${EXPECTED_IMAGE}"
            echo "ðŸ”§ Patching deployment with correct image..."
            kubectl set image deployment/backend -n ${DEV_NAMESPACE} backend=${EXPECTED_IMAGE} || {
              echo "Failed to set image, trying kubectl patch..."
              kubectl patch deployment backend -n ${DEV_NAMESPACE} -p '{"spec":{"template":{"spec":{"containers":[{"name":"backend","image":"'${EXPECTED_IMAGE}'"}]}}}}'
            }
            echo "ðŸ”„ Waiting for rollout to complete..."
            kubectl rollout status deployment backend -n ${DEV_NAMESPACE} --timeout=5m
            echo "âœ… Deployment updated!"
          fi
          
          echo ""
          echo "ðŸ“‹ Final pod details:"
          kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=backend -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.containers[0].image}{"\t"}{.status.phase}{"\n"}{end}'

  # Step 4: Deploy to Prod (requires approval)
  deploy-prod:
    name: 4ï¸âƒ£ Deploy to Prod (Requires Approval)
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'workflow_dispatch'
    timeout-minutes: 15
    environment: 
      name: production
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          spawn ssh-add "$env(HOME)/.ssh/id_ed25519"
          expect {
            "Enter passphrase" { send "$env(SSH_PASSPHRASE)\r"; exp_continue }
            "Identity added" { expect eof }
            timeout { exit 1 }
          }
          EXPECT_SCRIPT
          chmod +x /tmp/ssh-add.exp
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          /tmp/ssh-add.exp
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'" || exit 1

      - name: Setup SSH Tunnel to Kubernetes API
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:127.0.0.1:6443 root@72.62.40.154
          sleep 2

      - name: Configure kubectl
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          sed -i 's|server: https://.*:6443|server: https://127.0.0.1:6443|g' /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup backend-db-credentials secret for prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          if kubectl get svc postgres-backend-postgresql -n ${PROD_NAMESPACE} &>/dev/null; then
            DB_PORT=$(kubectl get svc postgres-backend-postgresql -n ${PROD_NAMESPACE} -o jsonpath='{.spec.ports[0].port}')
            DB_PASSWORD=$(kubectl get secret --namespace ${PROD_NAMESPACE} postgres-backend-postgresql -o jsonpath="{.data.password}" | base64 -d)
            
            kubectl create secret generic backend-db-credentials \
              --from-literal=postgres-host="postgres-backend-postgresql.${PROD_NAMESPACE}.svc.cluster.local" \
              --from-literal=postgres-port="$DB_PORT" \
              --from-literal=postgres-database="backend_db_prod" \
              --from-literal=postgres-username="backend_user" \
              --from-literal=postgres-password="$DB_PASSWORD" \
              --namespace ${PROD_NAMESPACE} \
              --dry-run=client -o yaml | kubectl apply -f -
          fi

      - name: Setup microsoft-graph-credentials secret for prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret generic microsoft-graph-credentials \
            --from-literal=tenant-id='e84f3a33-9e68-4a68-aae3-bebba66459e6' \
            --from-literal=client-id='70a6e6ef-c980-47dc-89ea-70ebd47fd56d' \
            --from-literal=client-secret='${{ secrets.MICROSOFT_CLIENT_SECRET }}' \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy backend to prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          fi
          echo "ðŸš€ Deploying to PRODUCTION with tag: ${IMAGE_TAG}"
          helm upgrade --install backend ./charts \
            --namespace ${PROD_NAMESPACE} \
            --create-namespace \
            -f env-values/prod/global.yaml \
            -f env-values/prod/backend.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
                --set imagePullSecrets[0].name=ghcr-secret \
                --rollback-on-failure --timeout=8m

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          echo "âœ… Production Deployment Status:"
          kubectl get pods -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=backend
          kubectl get svc -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=backend
